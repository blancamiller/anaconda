% Construct the features and reward function for the highway domain.
function [reward,features_pt,features_dyn] = highwayfeatures(mdp_params,mdp_data)

fprintf('highway_features: called \n')
fprintf("highwaybuild: NOTE - mdp_data.cars(input) currently for 'x'")
fprintf("currently empty b/c using dummy values\n")
fprintf('highway_features: mdp_data keys \n')
display(fieldnames(mdp_data))
%display(mdp_data.cars{1}.x0)
%display(mdp_data.cars{1}.x)

% Plot the course.
pts = [1.5 0.5;...
       3.5 0.5;...
       4.5 1.5;...
       4.5 2.5;...
       5.5 3.5;...
       6.5 3.5;...
       7.5 2.5;...
       7.5 1.5;...
       8.5 0.5;...
       9.5 1.5;...
       9.5 5.0;...
       8.5 6.0;...
       6.5 6.0;...
       5.5 7.0;...
       5.5 8.5;...
       4.5 9.5;...
       1.5 9.5;...
       0.5 8.5;...
       0.5 1.5];
lnmg = [0 -1;...
        0 -1;...
        1 0;...
        1 0;...
        0 -1;...
        0 -1;...
        -1 0;...
        -1 0;...
        0 -1;...
        1 0;...
        1 0;...
        0 1;...
        0 1;...
        1 0;...
        1 0;...
        0 1;...
        0 1;...
        -1 0;...
        -1 0];

% Create features array.
features_pt = cell(1,1+mdp_params.lanes+length(mdp_data.cars));

% Create lanes.
features_pt{1} = highwaybuildroad(pts);
#display(features_pt{1})

for j=2:mdp_params.lanes,
    % Decide if lane is outside or inside.
    if mod(j,2) == 0,
        sgn = 1;
    else
        sgn = -1;
    end;
    q = floor(j/2);
    
    features_pt{j} = highwaybuildroad(pts+lnmg*q*sgn* ...
                                      mdp_params.lane_space);
                                  
end;

%{
fprintf('features_pt{2}\n')
display(features_pt{2})
fprintf('features_pt{3}\n')
display(features_pt{3})
%}

% Create center lane.
features_pt{mdp_params.lanes+1} = features_pt{1};
features_pt{mdp_params.lanes+1}.width = 10;
%fprintf('WIDTH INDEX: %f \n', mdp_params.lanes+1)
fprintf('highwayfeatures: Center lanes (almost) match !\n')
fprintf('PYISSUE: width of features_pt{1}(features_pt[0]) is 10 not 1000.\n\n')

% Create speed feature.
features_pt{mdp_params.lanes+2} = struct('type','id','r',1.0,'idx',4);
fprintf('highwayfeatures: Speed features match !\n')
%fprintf('features_pt{mdp_params.lanes+2} Index: %f', mdp_params.lanes+2)
%display(features_pt{mdp_params.lanes+2})


% Create car features.
fprintf('highwayfeatures: --- NOTE: index 5 is not allocated x0 & x\n')

for i=1:length(mdp_data.cars),
    %fprintf('index i: %i\n', i)
    %fprintf('features_pt index: %f\n', mdp_params.lanes+2+i)
    features_pt{mdp_params.lanes+2+i} = struct('type','hwcar','width',200.0,'r',1.0,...
        'x',[mdp_data.cars{i}.x0; mdp_data.cars{i}.x],'lam',[4.0 1.0]);
end;

% Create dynamic features
features_dyn = cell(1,2);
features_dyn{1} = struct('type','dist','r',-1.0,'idx',1); % Gas.
features_dyn{2} = struct('type','dist','r',-1.0,'idx',2); % Steering.

% Create reward weights.
CAR_COST = 200.0;
LANE_VALUE = 20.0;
LANE_VALUE_BROAD = 200.0;
SPEED_VALUE = 100.0;
theta = [mdp_params.step_cost,...
         mdp_params.step_cost,...
         LANE_VALUE*ones(1,mdp_params.lanes),...
         LANE_VALUE_BROAD,...
         SPEED_VALUE,...
         -CAR_COST*ones(1,length(mdp_data.cars))];

% Create the reward.
reward = struct('type','sum','theta',theta,'features',{[features_dyn features_pt]});
